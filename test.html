<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<title>新年快乐 </title>  
<meta name="keywords" content="" />
<meta name="description" content="" />
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<!-- 引入字体文件 -->
	<style type="text/css">
		@font-face {
			font-family: digit;
			src: url("digital-7_mono.ttf"/*tpa=./digital-7_mono.ttf*/) format("truetype");
		}
	</style>
	<!-- 引入样式文件和JavaScript库 -->
	<link href="css/default.css" tppabs="./css/default.css" type="text/css" rel="stylesheet">
	<link rel="stylesheet" type="text/css" href="./css/default.css">
    <script type="text/javascript" src="js/jquery.js" tppabs="./js/jquery.js"></script>
	<script type="text/javascript" src="js/garden.js" tppabs="./js/garden.js"></script>
    <script type="text/javascript" src="js/functions.js" tppabs="./js/functions.js"></script>
    <body>
	<!-- 主体容器 -->
	<div id="mainDiv">
        <div style="position:relative; z-index:0"  >
            <canvas class="canvasContainer" id="canvasContainer"></canvas>
        </div> 
        <div id="floatingPlayer">
            <!-- 播放器控件，可以根据实际情况修改 -->
            <audio autoplay="autoplay" id="floatingAudio" controls>
                <source src="renxi.mp3" type="audio/mp3">
                Your browser does not support the audio element.
            </audio>
        </div>
               
		<div id="content">
			<!-- 音频播放器 -->
			<!-- <audio autoplay="autoplay" height="100" width="100">
				<source src="renxi.mp3" type="audio/mp3" />
				<embed height="100" width="100" src="renxi.mp3" />
			</audio> -->
			<!-- 代码区域 -->
			<div id="code">
				<span class="comments">亲爱的小狗：</span><br />
				<span class="space"><span class="comments">好久没和你聊天，都不知道该说些什么了。不得不说缘分这东西很神奇，我到现在还记得当初咱俩无话不聊的样子，从窗台的花聊到天上的月，从人间烟火聊到宇宙爆炸，＂酒逢知己千杯少，话不投机半句多＂那时的我们真的很开心。以至于在咱俩分开之后，我越来越讨厌和别人交流，其实你肯定知道，我是一个非常喜欢说话的人，没人陪我聊天真的会让我很难受。不过时间过得真快啊，转眼间2023就要结束了，都说旧人不入新年，可我还是舍不得你，随着新年的钟声愈发临近，我对你的思念也越来越浓。</span></span><br />
				<span class="space"/><span class="comments">但我不知道该怎么找你，你的态度让我不敢找你聊天，我害怕你会讨厌我卑微的样子，害怕你回想起最后那些不愉快的事让你难受，所以我想了这么个办法让你看见。在这个信息爆炸的时代，没有什么东西是永恒的，旧的照片会被新的照片覆盖，今天的热点事件也许明天就无人问津。但我把我们曾经的感情收藏，放到云端，无论世事如何变迁，它始终都在那里，可能它现在还很简陋，但我会不断去完善它。</span><br />
				<span class="space"/><span class="comments">你也许会问我这样有啥意义，人活几个瞬间，何必一直纠缠在回忆中呢？但是我觉得几个瞬间对于我们的感情来说真的不够，你总说我没有计划，确实，我平时做事是没啥计划，因为我喜欢无拘无束的感觉。可是你知道嘛？你在我心里一直就是那个可以陪伴终生的那个人，我知道我现在还差很多，但我心里其实一直在为咱俩的未来规划，我真的觉得我们可以一直走下去。是你说要在我的生活里处处留下痕迹，让我永远也离不开你，也是你说我们以后解决不了现实的问题，不如早点分开对双方都好。我是一个乐观的人，我觉得我有能力去解决以后可能面对的问题，本来这个元旦应该是咱俩一同漫步在贝尔格莱德的街头去感受古老欧洲的历史厚重，坐在波奇泰尔耶的山脚欣赏奥斯曼土耳其帝国曾经的沧桑，最后在一家小小的酒吧中一同庆祝我们一周年快乐！这是我幻想过无数次的画面，可它永远不可能实现了。很神奇的是，原来我们觉得的那些问题，无论时间还是金钱，都在命运的推动下迎刃而解了。谁也想不到我25号就考完了，和你的假期其实是完美契合的，谁也想不到后来我找到了个周末助教的工作，现在攒了10000多块钱，完全可以支持我们这趟旅行的开销。可惜命运弄人，最关键的我们却早早分开了，我多想回到那个时候，再劝说一下当时的咱俩，别那么轻易就分开，人与人能相遇相知相识，本就是天大的缘分了，多坚持一下，＂山重水复疑无路，柳暗花明又一村＂，生活中怎么会有解决不了的问题，相爱可抵万难。</span><br />
				<span class="space"/><span class="comments">看到这你可能又要反驳我了，说这都是幼稚的想法，现实哪会这么简单？咱俩其实都是要强的人，遇到问题非得争个输赢，但今天我认输，我没办法也不应该去赢一个在我心中最重要的人，让你赢才是我最应该做的事情。网上都说那个让你想要一直纠缠，费尽心思去追回来的人是你的情关，但我还是不想咱俩的缘分这么轻易就结束。其实有个很巧的地方，当时在一起的时候我发的朋友圈是＂我与太多人的缘分朝生暮死，犹如露水，唯独与你是一条生生不息的河流＂，七夕那时候发的是＂这是缘，亦是命中最美的遇见＂，那时候也是我们最恩爱的时候，最后一次是＂人与人的缘分相遇的时候就已经用尽了，剩下的都靠认为罢了＂。你看，缘分这东西是多么的奇妙啊，我知道我很多地方做的不好，我有时候关注不到你的情绪，有时候干傻事惹你生气，还得带着你一起吃以前没吃过的苦。但我真的一直在改，我也愿意为了你去改变自己，我想给你更好的生活。我不知道在分开的这段时间你是怎么想的，但我真的是在这段时间更深刻认识了自己。我一开始想让自己走出来，让自己避开这些情绪，把它们关起来，但我发现这样不行，你可以一时放下自己的情绪，但随着情绪的积累，在夜晚就会被更汹涌的情绪淹没。后来我学着去一点点接受自己的情绪，我发现，真的让我不断怀念的，是我们曾经一起畅想过得以后，我应该和你说过，我最羡慕的情侣是抖音上叫夏美的那对情侣，生命中没有什么事情是循规蹈矩的，和你在一起的时候我第一次感受到了什么是真正的生活，这是我一直想要的，也是我一直追求的生活，所以我才会那么喜欢你。之前翻相片的时候，我发现手机里好看的照片都是你的手机拍的，我拍的更多是丑丑的咱俩，但我觉得很真实，我很怀念这镜头下记录的曾经，我想真的爱上一个人，是你会很自然地去记录你们生活中发生的任何事情，无论高兴还是悲伤，我们的青春是短暂的，年华易逝，也许我们在某一天就会被人群淹没然后就这么老去。我想陪着你，记录你的点点滴滴，至少让你的青春在我这，是永恒的。这是这段时间不断思考后我对你的回答，也许我现在并不能陪着你去看古希腊的民主与自由，不能陪你去看古罗马的伟大与野蛮，下次还是不能陪你去看巴黎的华丽，伦敦的优雅，德国的古典。但我相信这只是缘分一次小小的失误，就如同我们短暂的分开一样，我想陪着你的以后，我会静静地等着你，直到你的回来。所以也请你不要厌烦，不要那么快把我忘掉，如果你还爱着我的话。</span><br />
                <span class="space"/><span class="comments">我知道我这么说很像画大饼，因为并没有什么实质的行动，但你肯定知道我是真心的，遇见你之后我就知道，我再也不会遇到像你这么好的人了，我不能说你再也不会遇上比我更好的人，因为你这么好，会遇到更多更好的人，值得更多更好的爱，但他们都不是我，不会像我一样如此纯粹的爱你。我好希望在2023的最后一天，你能回到我的身边，我真的很想你小狗，真的真的很想你。</span><br />
            </div>
			<!-- 画布和文字 -->
			<div id="loveHeart">
				<canvas id="garden"></canvas>
				<div id="words">
					<div id="messages">
						小狗, 这是我们在一起的第
						<div id="elapseClock"></div>
					</div>
					<div id="loveu">
						我真的好想你<br/>
						<div class="signature">- 最爱你的人</div>
				</div>
                <!-- 添加按钮 -->
<button id="navigateButton" onclick="navigateToOtherPage()">查看照片墙</button>


<!-- JavaScript脚本 -->
<script>
    function navigateToOtherPage() {
        // 修改下面的链接为你想要跳转的页面
        window.location.href = "2.html";
    }
</script>

<script>
    // 定义星星的颜色
    const STAR_COLOR = '#7a7281';
    // 定义星星的大小
    const STAR_SIZE = 4; // 减小星星大小
    // 定义星星的最小缩放比例
    const STAR_MIN_SCALE = 0.1;
    // 定义溢出阈值
    const OVERFLOW_THRESHOLD = 50;
    // 定义星星的数量
    const STAR_COUNT = (window.innerWidth + window.innerHeight) / 8; // 减少星星数量
    // 获取canvas元素
    const canvas = document.getElementById('canvasContainer');
    // 获取canvas的绘图上下文
    const context = canvas.getContext('2d');
    // 定义缩放比例
    let scale = 1; // device pixel ratio
    // 定义宽度和高度
    let width;
    let height;
    // 定义星星数组
    let stars = [];
    // 定义鼠标指针的位置
    let pointerX;
    let pointerY;
    // 定义速度对象
    let velocity = { x: 0, y: 0, tx: 0, ty: 0, z: 0.0005 }; // 减缓速度
    // 定义触摸输入标志
    let touchInput = false;
    // 生成星星
    generate();
    // 调整大小
    resize();
    // 运行动画
    step();
    // 当窗口大小改变时，重新调整大小
    window.onresize = resize;
    // 当鼠标在canvas上移动时，更新鼠标指针位置
    canvas.onmousemove = onMouseMove;
    // 当触摸屏在canvas上移动时，更新鼠标指针位置
    canvas.ontouchmove = onTouchMove;
    // 当触摸屏离开canvas时，更新鼠标指针位置
    canvas.ontouchend = onMouseLeave;
    // 当鼠标离开文档时，更新鼠标指针位置
    document.onmouseleave = onMouseLeave;
    // 生成星星
    function generate() {
        for (let i = 0; i < STAR_COUNT; i++) {
            stars.push({
                x: 0,
                y: 0,
                z: STAR_MIN_SCALE + Math.random() * (1 - STAR_MIN_SCALE),
            });
        }
    }
    // 将星星放置到随机位置
    function placeStar(star) {
        star.x = Math.random() * width;
        star.y = Math.random() * height;
    }
    // 回收星星并重新放置到新的位置
    function recycleStar(star) {
        // 初始化方向为 'z'
        let direction = 'z';
        // 获取速度的绝对值
        let vx = Math.abs(velocity.x);
        let vy = Math.abs(velocity.y);
        // 如果速度的绝对值大于1，则根据速度的大小随机确定方向
        if (vx > 1 || vy > 1) {
            let axis;
            // 如果水平速度大于垂直速度，则根据水平速度的比例随机确定水平或垂直方向
            if (vx > vy) {
                axis = Math.random() < vx / (vx + vy) ? 'h' : 'v';
            } else {
                axis = Math.random() < vy / (vx + vy) ? 'v' : 'h';
            }
            // 根据方向确定具体的移动方向
            if (axis === 'h') {
                direction = velocity.x > 0 ? 'l' : 'r';
            } else {
                direction = velocity.y > 0 ? 't' : 'b';
            }
        }
        // 随机设置星星的缩放比例
        star.z = STAR_MIN_SCALE + Math.random() * (1 - STAR_MIN_SCALE);
        // 根据方向设置星星的位置
        if (direction === 'z') {
            // 如果方向为 'z'，则将星星放置在屏幕中心
            star.z = 0.1;
            star.x = Math.random() * width;
            star.y = Math.random() * height;
        } else if (direction === 'l') {
            // 如果方向为 'l'，则将星星放置在屏幕左侧
            star.x = -OVERFLOW_THRESHOLD;
            star.y = height * Math.random();
        } else if (direction === 'r') {
            // 如果方向为 'r'，则将星星放置在屏幕右侧
            star.x = width + OVERFLOW_THRESHOLD;
            star.y = height * Math.random();
        } else if (direction === 't') {
            // 如果方向为 't'，则将星星放置在屏幕顶部
            star.x = width * Math.random();
            star.y = -OVERFLOW_THRESHOLD;
        } else if (direction === 'b') {
            // 如果方向为 'b'，则将星星放置在屏幕底部
            star.x = width * Math.random();
            star.y = height + OVERFLOW_THRESHOLD;
        }
    }
    // 调整大小
    function resize() {
        // 获取设备像素比例
        scale = window.devicePixelRatio || 1;
        // 设置画布的宽度和高度
        width = window.innerWidth * scale;
        height = window.innerHeight * scale;
        canvas.width = width;
        canvas.height = height;
        // 将所有星星重新放置到屏幕上
        stars.forEach(placeStar);
    }
    // 动画的每一帧
    function step() {
        // 清空画布
        context.clearRect(0, 0, width, height);
        // 更新星星的位置和速度
        update();
        // 绘制星星
        render();
        // 请求下一帧动画
        requestAnimationFrame(step);
    }
    // 更新星星的位置和速度
    function update() {
        // 缓动速度
        velocity.tx *= 0.96;
        velocity.ty *= 0.96;
        // 更新速度
        velocity.x += (velocity.tx - velocity.x) * 0.8;
        velocity.y += (velocity.ty - velocity.y) * 0.8;
        // 遍历所有星星
        stars.forEach((star) => {
            // 根据速度和缩放比例更新星星的位置
            star.x += velocity.x * star.z;
            star.y += velocity.y * star.z;
            // 根据速度和缩放比例更新星星的位置（使星星围绕屏幕中心旋转）
            star.x += (star.x - width / 2) * velocity.z * star.z;
            star.y += (star.y - height / 2) * velocity.z * star.z;
            // 更新星星的缩放比例
            star.z += velocity.z;
            // 更新星星的旋转角度
            star.o += 0.1;
            // 如果星星超出屏幕范围，则重新放置到屏幕上
            if (
                star.x < -OVERFLOW_THRESHOLD ||
                star.x > width + OVERFLOW_THRESHOLD ||
                star.y < -OVERFLOW_THRESHOLD ||
                star.y > height + OVERFLOW_THRESHOLD
            ) {
                recycleStar(star);
            }
        });
    }
    // 绘制星星
    function render() {
        // 遍历所有星星
        stars.forEach((star) => {
            // 设置绘制星星的样式
            context.beginPath();
            context.lineCap = 'round';
            context.lineWidth = STAR_SIZE * star.z * scale;
            context.globalAlpha = 0.5 + 0.5 * Math.random();
            context.strokeStyle = STAR_COLOR;
            // 绘制星星的路径
            context.beginPath();
            // 计算星星的尾巴坐标
            let tailX = Math.cos(star.o) * 5 * star.z; // 改进尾巴效果
            let tailY = Math.sin(star.o) * 5 * star.z;
            context.moveTo(star.x - tailX, star.y - tailY);
            context.lineTo(star.x, star.y);
            context.stroke();
        });
    }
    // 移动鼠标指针
    function movePointer(x, y) {
        // 如果之前有记录鼠标指针的位置，则计算鼠标指针的移动距离，并更新速度
        if (typeof pointerX === 'number' && typeof pointerY === 'number') {
            let ox = x - pointerX;
            let oy = y - pointerY;
            velocity.tx = velocity.tx + (ox / 8) * scale * (touchInput ? 1 : -1);
            velocity.ty = velocity.ty + (oy / 8) * scale * (touchInput ? 1 : -1);
        }
        // 更新鼠标指针的位置
        pointerX = x;
        pointerY = y;
    }
    // 当鼠标在canvas上移动时的事件处理函数
    function onMouseMove(event) {
        touchInput = false;
        movePointer(event.clientX, event.clientY);
    }
    // 当触摸屏在canvas上移动时的事件处理函数
    function onTouchMove(event) {
        touchInput = true;
        movePointer(event.touches[0].clientX, event.touches[0].clientY, true);
        event.preventDefault();
    }
    // 当鼠标离开canvas时的事件处理函数
    function onMouseLeave() {
        pointerX = null;
        pointerY = null;
    }
</script>

	<script type="text/javascript">
		// 一些变量和时间设置
		var offsetX = $("#loveHeart").width() / 2;
		var offsetY = $("#loveHeart").height() / 2 - 55;
		var together = new Date();
		together.setFullYear(2022, 12, 1);
		together.setHours(20);
		together.setMinutes(0);
		together.setSeconds(0);
		together.setMilliseconds(0);
		// 检查浏览器是否支持Canvas，如果不支持，显示错误消息
		if (!document.createElement('canvas').getContext) {
			var msg = document.createElement("div");
			msg.id = "errorMsg";
			msg.innerHTML = "提醒您：您的浏览器版本过旧^_^<br/>"+
				"推荐使用 <a href='http://dlsw.br.baidu.com/ditui/zujian/bdBrowserSetup-5956-ftn_1000061134.exe' target='_blank'>百度浏览器<br/>请先升级您的浏览器，效果很炫哦~~"; 
			document.body.appendChild(msg);
			$("#code").css("display", "none")
			$("#copyright").css("position", "absolute");
			$("#copyright").css("bottom", "10px");
		    document.execCommand("stop");
		} else {
			// 设置定时器，延迟一段时间后执行动画和其他操作
			setTimeout(function () {
				adjustWordsPosition();
				startHeartAnimation();
			}, 50);
			// 启动时间流逝计时器
			timeElapse(together);
			setInterval(function () {
				timeElapse(together);
			}, 500);
			// 调整代码区域位置，应用打字机效果
			adjustCodePosition();
			$("#code").typewriter();
		}
	</script>
	<!-- 背景音乐 -->
    <audio id="bgmMusic" src="http://qzone.haoduoge.com/music/C2C3F0LSXH4D771253124A26CF9C71C939B2A.mp3" preload="auto" type="audio/mp3" autoplay loop></audio>
    
	


</body>
</html>